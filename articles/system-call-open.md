---
title: "システムコールAPI"
emoji: "👏"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["linux"]
published: false
---
初心者のためのopen(O_CREAT | O_EXCL)で学ぶアトミック操作とレースコンディション

### はじめに: このテーマに興味を持ったきっかけ

プログラミングを始めたばかりの頃、**同時に実行される複数のプログラムが同じファイルを扱ったらどうなるんだろう？**という疑問が浮かびました。例えば、2つのプログラムが同時に同じ名前の一時ファイルを作成しようとした場合、どちらも成功してしまうのか、それとも片方が失敗するのか気になったのです。調べてみると、まさにこの問題に答える鍵としてLinuxのopenシステムコールのフラグ O_CREAT | O_EXCL が登場しました。さらに、この話題を追っていく中で「アトミック操作」や「レースコンディション」といった用語にも出会い、初心者なりに「これはどういう意味だろう？」と興味がどんどん膨らんでいきました。

実は、これはプログラム同士の「競争」に関する問題です。コンピュータ上では、多くのプログラムが同時に動いています。私たちには同時に動いているように見えても、CPUの中ではごく短い時間で切り替わりながら動作しています。この「切り替わり」の中で、プログラム同士が同じ資源（たとえば同じファイル）を取り合うように処理すると、順序次第で結果が変わってしまうことがあります。このような状況をレースコンディション（競合状態）と呼びます ￼。最初は難しく感じましたが、自分の疑問を軸に調べてみるととても興味深いテーマでした。本記事では、その学びを踏まえて、初心者にも分かりやすい言葉でopen(O_CREAT | O_EXCL)を使ったアトミックなファイル操作とレースコンディションの話を紹介したいと思います。

### open(O_CREAT | O_EXCL) ってなに？

まずは主役である open(O_CREAT | O_EXCL) から説明しましょう。Linuxではファイルを開くときにopenという関数（正確にはシステムコール）を使います。openには色々なフラグ（オプション）を指定できますが、その中でも O_CREAT と O_EXCL という2つのフラグの組み合わせがポイントです。
- O_CREAT: このフラグは「もし指定したファイルが存在しなかったら新しく作る」という意味です。モード（パーミッション）も指定して、ファイルを作成できます。
- O_EXCL: こちらは「排他(exclusive)」を意味するフラグで、O_CREATと一緒に指定すると指定したファイルが既に存在していたらopenを失敗させるという効果があります ￼ ￼。

では、O_CREAT | O_EXCLを組み合わせるとどうなるでしょうか？簡単に言えば、**「そのファイルがまだ無ければ作成して開くけれど、一瞬でも先に誰かが作っていたら開かない（失敗する）」**という動作になります。実際、Linuxのドキュメントには次のように説明されています。

O_EXCLフラグは、O_CREATフラグと組み合わせて使用すると、指定したファイルが既に存在する場合にopen呼び出しが失敗することを意味します。ファイルが存在しなければ、新規作成して開こうと試みます ￼。

もう少し噛み砕いて言うと、open("example.txt", O_CREAT | O_EXCL | O_WRONLY, 0666)のように呼び出すと、もしexample.txtというファイルが無ければ新しく作成して開く（このとき自分が**“そのファイルを作ったプログラム”**になります）。一方、すでにexample.txtが存在した場合にはエラーになり、開くこともしません。エラーの場合、openは-1を返し、エラーの理由としてerrnoという変数にEEXIST（「既に存在する」）というコードがセットされます ￼。

では、これが何の役に立つのでしょう？代表的な使い方の一つは**「ロックファイル」**の実現です。ロックファイルとは、あるリソースを一度に一つのプロセスしか使わないようにするための目印ファイルです。例えば、あるプログラムを二重起動したくないとき、起動時にmyapp.lockというファイルを作っておき、2つ目のプロセスはそのファイルがあったら動かないようにする、といった使い方です。このときopen(..., O_CREAT | O_EXCL)でロックファイルを作れば、複数のプロセスが同時に同じファイルを作成しようとしても、最初の1つだけが成功し他は失敗するので、簡単なロック機構として使えるのです ￼。

また、一時ファイルの作成にも利用できます。例えば/tmpのような多くのプログラムがファイルを置くディレクトリで、予期せぬ名前の衝突を避けたい場合があります。O_CREAT | O_EXCLでファイルを作れば「その瞬間に存在していない名前」でファイルを作れるので、他のプロセスと偶然同じ名前のファイルを作ってしまうリスクを下げられます。実際、C言語のmkstemp関数（安全な一時ファイル名を生成する関数）は内部でopenをO_CREAT | O_EXCL付きで呼び出して、他と被らないファイルを生成しています ￼。

つまり**open(O_CREAT | O_EXCL)は「この操作は自分だけのものだ！」と主張するような特殊な開き方**なのです。他の誰か（別プロセス）が同じことをしようとしても、先にやった方が勝ちで、後から来た方は「もう先越された！」と失敗します。

### TOCTOU（Time of Check to Time of Use）問題とは？

さて、O_EXCLの話から少し離れて、「レースコンディション」の典型例として知られるTOCTOU問題について説明します。TOCTOUは Time Of Check to Time Of Use の略で、日本語では「チェック時と使用時の時間差」のように訳されます。ざっくり言えば、**「あるものを確認した時と、それを実際に使う時との間にズレがあると起きる問題」**です ￼。

ちょっと抽象的なので具体的な例を見てみましょう。次のようなプログラムを考えてください。

```
if (access("file", W_OK) != 0) {
    fprintf(stderr, "書き込みできません\n");
    exit(1);
}
// ここで一旦プログラムが何もしない隙ができたと想像してください
int fd = open("file", O_WRONLY);
write(fd, buffer, sizeof(buffer));
```

これは「まずfileというファイルに書き込めるか確認し、問題なければそのファイルを書き込む」という処理です。一見問題なさそうですが、確認（Check）と実際の書き込み（Use）の間に注目してください。この隙間にもし悪意のある操作が入り込めたら…？実はこの間に別のプロセスがfileへのシンボリックリンクを操作することで、本来書くべきでない重要ファイル（例えば/etc/passwdなど）に内容を書き込ませてしまう攻撃が可能です ￼。これは実際にCTF競技などでも出題される有名な脆弱性の例で、fileのアクセス権をチェックした直後にfileを/etc/passwdに差し替える（シンボリックリンクを張り替える）ことで、本来一般ユーザーが書き込めないはずの/etc/passwdにデータを書けてしまいます ￼。

図: ファイルの利用権をめぐるAとBの競争。状態1でAが「Aが使うよ」と書いたが、次の瞬間状態2でBに「Bが使うよ」と書き換えられてしまったため、Aは「あれれ？（自分が使うはずだったのに）」となっている。

上の図は、人間に例えてTOCTOU的な状況を表したものです。Aさんが会議室のホワイトボードに「Aが使うよ」（自分が使うと宣言）と書いて安心していたところ、少し目を離した隙にBさんがそれを消して「Bが使うよ」と書き換えてしまいました。Aさんが戻ってみると自分の書いたはずの宣言はなくなっており、「あれ、おかしいぞ？」となっています。この例ではAさんが最初にチェック（自分の名前を書いて予約したつもり）し、その後本当に使おう（利用）としたときに、間の時間でBさんに横取りされていたわけです。

TOCTOU攻撃とは、このように**「チェックしたときと使うときで対象が変わってしまう」**というレースコンディションの脆弱性を悪用する手法です ￼。プログラム側から見ると、チェックした対象と実際に操作した対象が異なってしまうため、想定外の動作が起きてしまいます ￼。先ほどの例では、「書き込んでいいかチェックしたファイル」と「実際に書き込んだファイル」が別物になってしまったため、本来ならエラーになるべき操作（/etc/passwdの書き換え）が通ってしまいました。

この問題の怖いところは、**「一見連続して書いたコードでも、完全には連続して実行される保証がない」という点です。プログラムを読んで「チェックしてから使っているから安全だろう」と考えても、その「ほんのわずかな隙」**をついて他の処理が入り込むかもしれないのです ￼。特にファイル操作では、完全にチェックと利用を不可分にすることは難しく、対策が取りづらい脆弱性として知られています ￼。このようなTOCTOUのリスクを避けるためには、初めからOSに用意されたアトミックな操作を使うなどの工夫が必要になります。ここで冒頭のopen(O_CREAT | O_EXCL)が再び役立ってくるわけです。

### タイムスライスとプロセス切り替え — レースコンディションが起きる理由

では、なぜ先ほど述べたような「ほんのわずかな隙」が生まれてしまうのでしょうか。それを理解するにはOSの動かし方を知る必要があります。キーワードは 「タイムスライス」 と 「プロセスの切り替え（コンテキストスイッチ）」 です。

タイムスライスとは、コンピュータのCPUが各プログラム（プロセス）に順番に割り当てる時間のきりみたいなものです ￼。現代のOSはマルチタスクが当たり前で、複数のプログラムを同時に実行できます。しかし、一つのCPUコアは一度に一つのことしかできません。そこで、**ごく短い時間（数ミリ秒程度）**ごとに実行するプロセスを切り替えることで、あたかも複数のプログラムが同時に走っているように見せているのです ￼。この短い時間枠がタイムスライスで、OSのスケジューラと呼ばれる仕組みが「次はどのプロセスを動かそうか？」と順番を決めています ￼。

例えば、プロセスAとプロセスBの2つが動いている場合を考えてみましょう。最初のタイムスライスではAがCPUを使います。しかし時間が来るとOSはAを一時停止してBを動かします。その次のタイムスライスではまたAに戻るかもしれません。この切り替えの瞬間のことを**コンテキストスイッチ（文脈の切り替え）**と呼びます。OSはAの「やりかけの状態（レジスタやメモリの内容）」を保存し、Bの状態をロードして実行を再開します。そして次にAに戻るときは保存しておいた状態を戻して続きを実行します。こうすることで、AもBも少しずつ前に進み、同時に動いているように見えるわけです。

このコンテキストスイッチがレースコンディションの原因になり得ます。なぜなら、プログラムの途中で唐突に実行が中断され、別のプログラムに処理が移ってしまうことがあるからです。TOCTOUの例に照らしてみましょう。
- タイムスライス1（プロセスA）: プロセスAがif (access("file", W_OK) != 0) {...}を実行し、ファイルfileのチェックをしました。この時点ではfileは存在せず、Aは「まだファイルは無いな、よしこの後作業しよう」と思っています。
- （コンテキストスイッチが発生）
- タイムスライス2（プロセスB）: OSがAを一時停止し、Bを動かしました。すると運悪く（あるいは悪意を持って）Bもfileを操作するコードを走らせました。Bはopen("file", O_CREAT | O_WRONLY)などで**fileを新規作成してしまいました（O_EXCLを付けていなければ既存チェックはしないので作れてしまいます）。こうしてBが先にfileを作って書き込み**を行いました。
- （再びコンテキストスイッチ）
- タイムスライス3（プロセスA）: CPUがAに戻ってきました。Aは先ほどアクセス権チェックをパスしたので、次にfd = open("file", O_WRONLY);を実行します。しかし既にBがfileを作成済みです。Aは自分が想定しない状態になっていることに気付かぬままファイルを開き、書き込もうとします。場合によってはfileの中身をBとAが競合しておかしなデータになるかもしれませんし、Aが書こうとした先が本来意図しないものになっているかもしれません。

このように、タイムスライスによるプロセス切り替えのせいで、プログラムの処理手順の間に別のプログラムの処理が割り込んでしまうのです。マルチコアCPUであれば、極端な話本当に同時並行でAとBが走るので、タイミング次第では上記のような「挿し違い」動作が起こり得ます。レースコンディションとは、まさにこうした並行動作の競争によって起きる予期せぬ結果なのです ￼。

ポイントは、単一のプログラムの中では当たり前と思っている実行順序が、OS全体で見ると保証されていないということです。プログラマから見ると「AしてからBしているのだから、絶対Aが先に終わっている」と思っても、OS上ではAの途中でスパッと切り替わって別の処理が入り込み、戻ってきたときには状況が変わっている可能性があります。これが**「時間のずれ」による問題＝TOCTOU**の正体です。

### open(O_CREAT | O_EXCL) を使った実験

理論の話ばかりでは退屈かもしれませんので、実際にopen(O_CREAT | O_EXCL)の効果を体験できる簡単な実験をしてみましょう。ここではC言語でプログラムを書いてみますが、難しい内容はないので雰囲気だけ掴んでもらえれば大丈夫です。

以下は、ロックファイルの例にも似たシナリオで、同じファイルを2つのプロセスが同時に作ろうとしたときにどうなるかを見るプログラムです。

```
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>

int main(void) {
    const char *lockfile = "lockfile.tmp";
    int fd = open(lockfile, O_CREAT | O_EXCL | O_WRONLY, 0644);
    if (fd >= 0) {
        printf("ファイル作成に成功しました！（ロック取得）\n");
        // とりあえず5秒間ファイルを保持してから終了
        sleep(5);
        close(fd);
    } else {
        printf("ファイル作成に失敗: %s\n", strerror(errno));
    }
    return 0;
}
```

このプログラムは、現在のディレクトリにlockfile.tmpというファイルを新規作成します（存在しない場合のみ）。成功すれば「ファイル作成に成功しました！（ロック取得）」と表示し、失敗すればエラーメッセージ（例えば「File exists（ファイルが存在します）」）を表示します。sleep(5)で5秒待っているのは、意図的にファイルをしばらく保持するためです。

### 実験手順
1.	上記のコードをファイル（例えばtest_excl.c）に保存してコンパイルします。コンパイルにはgccなどのCコンパイラを使いましょう。例:

```
gcc -o test_excl test_excl.c
```

これでカレントディレクトリにtest_exclという実行ファイルができるはずです。

2.	ターミナルを2つ開いてください（あるいは2つのコンソールセッションを準備します）。一方のターミナルでプログラムを実行します。

```
./test_excl
```

実行すると「ファイル作成に成功しました！（ロック取得）」と表示され、5秒間プロセスが終了せずに待機状態になります。

3.	上記を実行してから5秒以内に、もう一方のターミナルでも同じプログラムを実行してみましょう。

```
./test_excl
```

今度はどうなるでしょうか？おそらく、2つ目の実行では「ファイル作成に失敗: File exists」のようなメッセージが表示されるはずです。最初のプロセスがすでにlockfile.tmpを作成して保持しているため、2つ目のプロセスのopen(O_CREAT | O_EXCL)は既存ファイルの存在を検知してエラーになったのです ￼。

4.	5秒経って最初のプロセスが終了すると、lockfile.tmpというファイルがディレクトリに残ります（プログラム中では削除していないため）。不要であればこのファイルを手動で削除してください (rm lockfile.tmp)。

### 観察結果

この実験からわかることは、O_EXCL付きのopenは同名のファイルを同時に作ろうとする競合を防いでくれるという点です。最初のプロセスがファイルを作成できたら、ほんの数秒後でも2つ目のプロセスは同じ名前で作成することはできませんでした。2つ目はエラーで失敗し、その事実を知ることができます。

一方、もしこのプログラムでO_EXCLを付けずに単にopen(lockfile, O_CREAT | O_WRONLY, 0644)としていたらどうなるでしょうか。その場合、最初のプロセスがファイルを作成した後であっても、2つ目のプロセスはエラーにならず既存のファイルを普通に開いてしまいます。つまり両方のプロセスが同じファイルに書き込める状態になってしまうのです。これではロックの意味がありませんし、下手をするとファイルの内容を互いに上書きして不整合が生じる可能性もあります。

この違いを生み出しているのがO_EXCLフラグの効力です。openが内部で「ファイルの存在確認と作成」を**一体化した不可分の操作（アトミック操作）**として行ってくれているおかげで、チェックと作成の間に他が入り込む余地が無いのです。

### なぜこの方法がアトミックで安全なのか？

**アトミック(不可分)**とは「それ以上分割できない、一塊の」という意味の言葉です。コンピュータの操作でこれを言うときは、「途中の状態が観察されない・割り込まれない操作」を指します ￼。つまり、ある処理の途中経過が他から見えず、やるなら全部一気にやるし、ダメなら何もしないという性質です ￼。

open(O_CREAT | O_EXCL)が安全と言われるのは、まさにこの操作がアトミックに行われるからです。先の実験の通り、openシステムコール一つで「ファイルが存在するか確認し、存在しなければ作成して開く」という一連のことをOSが引き受けてくれます。重要なのは、この間にユーザープロセスのコードには制御が戻らないということです。openの処理中はカーネル（OS）がまとめて面倒を見てくれるので、他のプロセスが割り込んで「そのファイルを横取りで作る」スキを与えません。

これをもう少しかみ砕いてイメージしてみましょう。普通、ユーザー空間でプログラムを書いていると、
1.	「ファイルが存在するか調べる」（OSに頼む）
2.	（結果をもとに）「ではファイルを作成する」（またOSに頼む）

という風に、2回OSにお願いをすることになります。しかし、open(O_CREAT | O_EXCL)を使うと1回のお願いで済みます。ユーザーからOSへの依頼回数が1回であれば、お願いしている最中に他のことはできませんよね。これがアトミック操作の利点です。「確認と作成」をワンセットの一括動作にしてしまい、他のプロセスに割り込むヒマを与えないのです ￼。

実際、Linuxカーネルの中ではファイルシステムに対するロック機構などを用いて、このopen処理がクリティカルセクション（一度に一つの実行しか許されない区間）として扱われます。カーネルは「今まさにexample.txtを作ろうとしているところ。他の人はちょっと待っててね」という感じで調整してくれます。その結果、ユーザー側から見ると**open(O_CREAT|O_EXCL)は「成功するか失敗するか」のどちらかで、中途半端な状態は起こらない**ことが保証されます ￼。成功すれば自分がファイルを新規作成できたし、失敗すれば誰かが先に作っていた（ので自分は何もしなかった）という明確な結果が得られます。

ただし、注意点もあります。ネットワーク越しのファイルシステム（NFS）ではO_EXCLが完全に効かない場合があるという問題です ￼。古いNFS環境では、O_EXCLの情報が正しく伝わらず、クライアント同士で競合が起きてしまうケースが知られています ￼。現代ではNFSv3以降でO_EXCLがサポートされていますが、それ以前の環境では**「この方法なら絶対安全」と鵜呑みにせず、別のロック方法を検討する**必要があります ￼。例えば、ユニークな仮ファイルを作ってlinkシステムコールで目的の名前にリンクする方法などが文献で紹介されています ￼。とはいえ、ローカル環境や通常の用途であればopen(O_CREAT | O_EXCL)は非常に強力な武器になります。

まとめると、open(O_CREAT | O_EXCL)がアトミックで安全なのは、「ファイルの存在確認」と「ファイル作成」の2つの操作をOS内部で一度に行っているからです。他のプロセスから見ると、その瞬間はロックされているような状態になり、介入できません。したがって、レースコンディションを避けたい場面でopen(O_CREAT | O_EXCL)を使うことは有効な対策になるわけです。

### 実務での活用例いろいろ

最後に、この方法を実際のプログラミングでどう活かせるかをいくつか紹介します。ここまで出てきた話とも重複しますが、用途を整理してみましょう。
- ロックファイルの実装: 先述の通り、同時実行を防ぎたい処理でロックファイルを用意し、open(O_CREAT | O_EXCL)でそのファイルを作成することで簡易ロックができます ￼。例えばmyapp.lockを作って、起動時に作成できなかったら「すでに起動中」と判断して終了する、といった具合です。ただし、この方式ではプログラムが異常終了した際にロックファイルが残ってしまう問題もあるので、終了時に削除するか、起動時に古いロックを検知して削除する工夫も必要です（完全ではないので注意しましょう ￼）。
- 一時ファイル・ユニークファイルの作成: 複数プロセスが共通のディレクトリにファイルを作る場合、O_EXCL付きで開いて名前の衝突を防ぐことができます。例えば、他人と被らないような一時ファイルが欲しいとき、mkstempの内部実装にならってランダムな名前を生成しopen(O_CREAT|O_EXCL)で試み、失敗したらまた別の名前で…というアプローチがあります ￼。これにより、自分だけがその名前のファイルを作ったことを保証できます。
- 安全な設定ファイルの書き換え: アプリケーションが設定ファイルを書き換えるときに、内容が壊れたり同時更新で競合したりしないように工夫することがあります。その一つに一時ファイル＋置き換えの手法があります。例えば、新しい設定を書き込むときは config.new のような一時ファイルにまず書き出し、保存が完了したらrenameで本来のconfig.cfgに原子置換するという方法です。この一時ファイルconfig.newの作成にもO_CREAT|O_EXCLを使えば、複数のプロセスが同時に設定更新しようとしたときに「自分のconfig.newを作れなかったら他が更新中とみなす」ことができます。あるいは、バックアップファイルを残す前提でopenにO_EXCLを使い、「もし既にバックアップがあれば他が編集中だ」と判断するような同期方法も考えられます。
- 重複実行の防止: これはロックファイルと似ていますが、例えばスクリプトで「同じ処理を二度キューに入れてしまった」ようなケースを防ぐために、一意のファイルをキーにしておく方法があります。スクリプトの頭でopen(keyfile, O_CREAT|O_EXCL)を試し、失敗したら「このジョブは既に走っているか、キューに入っているな」と見なしてスキップする、といった実装です。keyfileにはプロセスIDなどを書いておくと、あとでデバッグ時に「どのプロセスがロックを持っていたか」分かるメリットもあります。

以上のように、open(O_CREAT | O_EXCL)は**「同じものが既にあるかどうか」を問いつつ「無ければ作る」を一発でやりたいシーンでとても有用です。特にファイル名を使ったロックや一意性の保証に関連する場面では強力な味方になります。ただ、当然ですがこの方法はファイルシステムを使うことが前提なので、「ファイル以外のリソース」には使えません。例えばネットワークソケットやメモリ上のデータには別の同期手段が必要です。またファイルロックの他の方法（flockやfcntlのロックなど）と比べて、ファイルを実際に作成する分オーバーヘッド（ディスクI/O）が発生する**点も留意しましょう ￼。用途に応じて、適材適所で使うことが大切です。

### おわりに – 学びのまとめと今後に向けて

ここまで、初心者の方向けに**open(O_CREAT | O_EXCL)によるアトミックなファイル作成とレースコンディション（TOCTOU問題）**について解説してきました。最後に、今回の内容を簡単に振り返ってみましょう。
- レースコンディションとは、複数の処理がほぼ同時に同じリソースへアクセスすることで起こる予期せぬ競合のこと ￼。特にTOCTOUは「チェックと利用のタイミングのずれ」による典型的な競合パターンで、ファイル操作における脆弱性の一つです ￼。
- タイムスライスとプロセス切り替えにより、プログラムの実行は細切れに分割されます。一見直列な処理でも、途中に別の処理が割り込む可能性があるため、単純な実装ではレースコンディションが発生し得ます。
- open(O_CREAT | O_EXCL)はファイル存在の確認と作成をアトミックに行う方法です。複数プロセスが同時に実行しても、一番乗りの1つだけが成功し、他は失敗するので競合状態を防げます ￼。OSがこの操作を一括で扱うため、途中で割り込まれる心配がありません。
- このテクニックを使うことで、ロックファイルの実現や一時ファイルの衝突防止、安全なファイル更新など、実務上の様々な場面でより堅牢なプログラムを書くことができます。

技術的な話を色々としましたが、要するに**「コンピュータは並行に色んなことが起きるので、ちゃんと対策しよう」ということに尽きます。そして対策の一つとしてOSが用意している原子操作を活用しよう**というのが今回のテーマでした。

今回学んだアトミック操作の考え方は、ファイルに限らずデータベースやマルチスレッド処理など広い分野で重要になります。例えばデータベースではトランザクションという仕組みで「一連の操作を不可分に実行する」ことを保証していますし、並行プログラミングではアトミック変数やロックでデータ競合を防いでいます。ぜひ皆さんも、自分の書くプログラムで「ここは他と競合しないかな？」「原子的に処理すべきかな？」と考えてみてください。そして、もし過去に遭遇したバグや不具合で「もしかしてあれはレースコンディションだったのかも？」と思い当たることがあれば、今回の内容をヒントに対策を検討してみるのも良いでしょう。

最後まで読んでいただきありがとうございました！今回の内容はあなたのプログラミングにどう役立ちそうでしょうか？ぜひ、自分なりの活用アイデアや疑問点などを考えてみてください。もしかすると、新しい視点でシステム設計やコードの改善点が見えてくるかもしれませんね。それでは、安全で堅牢なプログラミングを楽しんでいきましょう！ 🏁

### 参考文献・情報源：（本記事では以下の資料を参考にしました）
- Linux Man Pages 日本語訳  ￼ ￼ ￼
- IPA「安全なプログラミング講座」よりレースコンディションの解説 ￼
- SOMPOサイバーセキュリティ用語集 TOCTOU攻撃 ￼
- Qiita記事: TOCTOU攻撃を試してみる ￼
- StackExchange回答: Mark Plotnick氏の説明 ￼ ￼
- Wikipedia: タイムスライスとプリエンプション ￼ ￼
- ITmedia記事: ファイルロック方法の考察 ￼
---


1. 導入：一つのフラグから広がった世界
- 	Linuxプログラミングを学んでいて出会った open(O_CREAT | O_EXCL)。
- 	最初は「ファイルを安全に作成するための便利なフラグ」くらいに思っていた。
- 	しかしその背後にはプロセスの並行実行やアトミック操作という奥深い世界が広がっていた。
- 	本記事では、このフラグを入り口に、システムコール、アトミック、そしてタイムスライスとレースコンディションについて考えていく。

⸻

2. open(O_CREAT | O_EXCL) の役割と危険なパターン

2.1 フラグの意味
- 	O_CREAT：ファイルがなければ新規作成
- 	O_EXCL：ファイルがすでに存在すればエラー（EEXIST）
- 	この組み合わせにより、「存在確認」と「新規作成」を一度に実行できる。

2.2 悪い例：access() → open()
- 	存在確認と作成を分けて書くと、間に他のプロセスが割り込む可能性がある。
- 	これはTOCTOU（Time Of Check To Time Of Use）問題と呼ばれる。

if (access("file.txt", F_OK) == -1) {
    open("file.txt", O_WRONLY | O_CREAT); // ← ここで割り込みが入るかも
}


⸻

3. レースコンディションはなぜ起きるのか：タイムスライス登場

ここでタイムスライスという概念が登場する。

3.1 タイムスライスとは
- 	OSは複数プロセスを同時に動いているように見せるため、CPU時間を細かく分割して使わせる。
- 	1つのプロセスがCPUを占有できる最大時間がタイムスライス。
  -	例: 10msで切り替え

3.2 割り込みの瞬間に起きること
- 	プロセスAが1回目のopen()で「ファイルが存在しない」と判断
- 	しかしタイムスライスが切れて、CPUがプロセスBに切り替わる
- 	プロセスBが同じファイルを作成
- 	再びプロセスAが実行され、2回目のopen()を実行
- 	→ Aは「自分が作成した」と誤認してしまう

時間 →
┌──────────────┬──────────────┬──────────────┐
|  プロセスA        |  プロセスB        |  プロセスA再開   |
|  open(存在確認)   |  open(作成)      |  open(2回目)     |
└──────────────┴──────────────┴──────────────┘
         ↑タイムスライス終了 → CPUがAからBに切り替わる

これが典型的なレースコンディション発生シナリオ。

⸻

4. open(O_CREAT | O_EXCL) で解決できる理由
- 	open(O_CREAT | O_EXCL) は存在確認＋新規作成を1回のシステムコールでアトミックに実行する。
- 	OSが内部でロックを取り、処理が割り込まれない。
- 	これによりTOCTOU問題を解消できる。

⸻

5. アトミック操作とは何か
- 	アトミック＝「分割されず、一連の操作が他プロセスから見て一瞬で終わる」こと。
- 	ここで重要なのは、「システムコールだから常にアトミック」というわけではないという点。
- 	例：
  -	open(O_CREAT | O_EXCL) → アトミック保証あり（仕様で明記）
  -	read() → アトミック保証なし
  -	write() → パイプに4,096バイト以下ならアトミック

→ アトミック性はシステムコールごとに異なる。

⸻

6. 実験：タイムスライスを使ったレースを再現
- 	2つのプロセスを並列に実行し、意図的にTOCTOUを発生させる。
- 	片方がファイル作成に成功、もう片方が誤って上書き。
- 	次に O_CREAT | O_EXCL を使うと片方はEEXISTで失敗することを確認。

⸻

7. 公式ドキュメントで裏付け
- 	man 2 open
This is guaranteed to be atomic.
- 	POSIX仕様
without the possibility of a race condition
- 	実装レベルでは、カーネルがinodeロックを使ってアトミック性を保証。

⸻

8. 応用例
- 	ロックファイル：排他制御をシンプルに実現
- 	一時ファイル作成：mkstemp() や O_TMPFILE
- 	安全なファイル更新：一時ファイル→fsync()→rename()（renameも多くのFSでアトミック）

⸻

9. まとめ：タイムスライスとアトミックを意識する
- 	タイムスライスによるCPU切り替えが、並列実行環境では必ず起きる。
- 	その切り替えがレースコンディションの根本原因。
- 	open(O_CREAT | O_EXCL) は、こうした割り込みの隙間をなくす「アトミックな武器」。
- 	システムコールの設計意図を理解することで、より堅牢なプログラムが書ける。

⸻

本記事で伝えたいこと
- 	open(O_CREAT | O_EXCL) というフラグをきっかけに、
  -	プロセススケジューリング（タイムスライス）
  -	レースコンディション
  -	アトミック操作
を体系的に理解できる。
- 	Linuxプログラミングは、APIの使い方を覚えるだけではなく、OS内部の仕組みと連動して理解することが重要。

⸻
